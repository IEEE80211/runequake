#!/usr/bin/perl5 -w
use strict;

# $Id: map,v 1.1 2002/02/21 21:47:54 slotzero Exp $
#
# Copyright (c) 2001, 2002 Rune Quake Development Team.  All rights reserved.
# See the file `Copying' in the distribution for terms.

(my $Me = $0) =~ s-.*/--;

my %lan = map { $_ => 1 } qw(e1m7 e1m8 end);

my @lev = (
	[], # unused

	[ # small
		'start',# Introduction
		'e1m6',	# The Door To Chthon
		'e1m7',	# The House of Chthon
		'e3m2',	# The Vaults of Zin
		'e3m3',	# The Tomb of Terror
		'e3m7',	# The Haunted Halls
		'end',	# Shub-Niggurath's Pit
		'dm1',	# Place of Two Deaths
		'dm4',	# The Bad Place
		'dm5',	# The Cistern
		'dm6',	# The Dark Zone
	],

	[ # medium
		'e1m1',	# The Slipgate Complex
		'e1m2',	# Castle of the Damned
		'e1m3',	# The Necropolis
		'e1m4',	# The Grisly Grotto
		'e1m8',	# Ziggurat Vertigo
		'e1m5',	# Gloom Keep
		'e2m1',	# The Installation
		'e2m2',	# The Ogre Citadel
		'e2m3',	# Crypt of Decay
		'e2m7',	# Underearth
		'e2m6',	# The Dismal Oubliette
		'e3m1',	# Termination Central
		'e3m4',	# Satan's Dark Delight
		'e3m6',	# Chambers of Torment
		'e4m1',	# The Sewage System
		'e4m2',	# The Tower of Despair
		'e4m6',	# The Pain Maze
		'dm2',	# Claustrophobopolis
		'dm3',	# The Abandoned Base
	],

	[ # large
		'e2m4',	# The Ebon Fortress
		'e2m5',	# The Wizard's Manse
		'e3m5',	# Wind Tunnels
		'e4m3',	# The Elder God Shrine
		'e4m4',	# The Palace of Hate
		'e4m5',	# Hell's Atrium
		'e4m8',	# The Nameless City
		'e4m7',	# Azure Agony
	],
);

# Construct %wan, the list of levels which aren't in %lan.
my %wan;
for my $size (1..$#lev)
{
	for my $map (@{ $lev[$size] })
	{
		if (exists $wan{$map})
		{
			die "$Me: duplicate entry for $map\n";
		}
		$wan{$map} = 1;
	}
}
for my $map (keys %lan)
{
	delete $wan{$map} or die "$Me: invalid \%lan entry $map\n";
}

print "// This file is automatically generated by the $Me script.\n";
print "// Don't edit it, edit the script instead.\n";
print "\n";

print "float (float levsize)\n";
print "sized_map_count =\n";
print "{\n";
for my $size (1..$#lev)
{
	my $max = scalar @{ $lev[$size] };
	print "\tif (levsize == $size) return $max;\n";
}
print "\terror (\"invalid arg\");\n";
print "};\n";

print "\n";
print "string (float levsize, float n)\n";
print "sized_map =\n";
print "{\n";
for my $size (1..$#lev)
{
	print "\tif (levsize == $size) {\n";
	my $ix = 0;
	for my $map (@{ $lev[$size] })
	{
		$ix++;
		print "\t\tif (n == $ix) return \"$map\";\n";
	}
	print "\t}\n";
}
print "\terror (\"invalid arg\");\n";
print "};\n";

print "\n";
print "float (string m)\n";
print "map_size =\n";
print "{\n";
for my $size (1..$#lev)
{
	for my $map (@{ $lev[$size] })
	{
		print "\tif (m == \"$map\") return $size;\n";
	}
}
print "\treturn 0;\n";
print "};\n";

my $wan = keys %wan;
my $lan = $wan + keys %lan;
print "\n";
print "string ()\n";
print "rand_map =\n";
print "{\n";
print "\tlocal float i, n;\n";
print "\n";
print "\tif (deathmatch & DM_LAN_MODE)\n";
print "\t\tn = $lan;\n";
print "\telse\n";
print "\t\tn = $wan;\n";
print "\ti = ceil (random () * n);\n";
my $i = 0; my $cmp;
for my $map (keys %wan, keys %lan)
{
	$i++;
	if ($i == 1)		{ $cmp = "<="; }
	elsif ($i == $lan) 	{ $cmp = ">="; }
	else			{ $cmp = "=="; }
	print "\tif (i $cmp $i) return \"$map\";\n";
}
print "\terror (\"invalid map number\");\n";
print "};\n";

print "\n";
print "string ()\n";
print "impulse_to_map =\n";
print "{\n";
for my $map (map { @$_ } @lev ) {
    my $impulse = $map;
    if ($map =~ /^dm([1-6])$/)	{ $impulse = "5$1" }
    elsif ($map eq 'start')	{ $impulse = 57 }
    elsif ($map eq 'end')	{ $impulse = 58 }
    else 			{ $impulse =~ tr/0-9//cd or die "oops `$map'" };
    print "\tif (self.impulse == $impulse) { return \"$map\"; }\n";
}
print "\treturn string_null;\n";
print "};\n";

my $no_frags	= -23000;
my $team_min	= 1;
my $team_max	= 14;
my $team_nil	= $team_min - 1;
my $team_none	= $team_min - 2;
my $team_tie	= $team_min - 3;
my ($else, $s);

print "\n";
print "float";
$s = '';
for my $t ($team_nil, $team_min .. $team_max) {
    $s .= " tf_$t,";
}
chop $s;
print "$s;\n";

print "\n";
print "void ()\n";
print "frag_init =\n";
print "{\n";
print "\t";
for my $t ($team_nil, $team_min .. $team_max) {
    print "tf_$t = ";
}
print "$no_frags;\n";
print "};\n";

print "\n";
print "void (entity e, float f)\n";
print "add_frag =\n";
print "{\n";
print "\tif (deathmatch & DM_DAMAGE_MATCH && !damage_match_hack) return;\n";
print "\tif (e.runetype == RN_PACK_RAT && f > 0 && !deathmatch & DM_DAMAGE_MATCH) f = f + f * pack_rat_frag_bonus_e (e);\n";
print "\te.frags = e.frags + f;\n";
print "\te.recent_frags = e.recent_frags + f;\n";
$else = '';
for my $t ($team_min .. $team_max, $team_nil) {
    print "\t${else}";
    print "if (e.team == $t) " if $t != $team_nil;
    print "{ if (tf_$t == $no_frags) tf_$t = f; else tf_$t = tf_$t + f; }\n";
    $else = 'else ';
}
print "};\n";

print "float (entity e)\n";
print "team_stats_1 =\n";
print "{\n";
print "\tlocal float t, f, lead, n_teams;\n";
print "\tsprint (e, \"Team frag totals:\\n\");\n";
print "\tn_teams = 0;\n";
for my $t ($team_nil, $team_min .. $team_max) {
    print "\tif (tf_$t != $no_frags)\n";
    print "\t{\n";
    print "\t\tn_teams = n_teams + 1;\n";
    print "\t\tsprint_int_f (e, tf_$t, 4);\n";
    print "\t\tsprint (e, \" \");\n";
    print "\t\tsprint_team (e, $t);\n";
    print "\t\tsprint (e, \"\\n\");\n";
    print "\t}\n";
}
print "\tt = $team_none;\n";
print "\tf = $no_frags;\n";
print "\tlead = $no_frags;\n";
for my $t ($team_nil, $team_min .. $team_max) {
    print <<EOF
	if (tf_$t != $no_frags)
	{
		if (tf_$t > f)
		{
			if (f == $no_frags)
				lead = $no_frags;
			else
				lead = tf_$t - f;
			f = tf_$t;
			t = $t;
		}
		else if (tf_$t == f)
			t = $team_tie;
		// Same leader, but this team came closer than the
		// previous contender, so update the frag difference.
		else if (lead == $no_frags || f - tf_$t < lead)
			lead = f - tf_$t;
	}
EOF
}
print "\tteam_stats_1_lead = lead;\n";
print "\treturn t;\n";
print "};\n";
